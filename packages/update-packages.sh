#!/usr/bin/env bash
set -euo pipefail

# Regenerate package lists from the current system.
#
# Output files:
# - all-packages.txt     : pacman explicit packages (includes AUR/foreign if installed)
# - aur-packages.txt     : pacman foreign packages (typically AUR)
# - flatpak-packages.txt : flatpak app IDs
# - go-packages.txt      : go-installed tools (best-effort; derived from Go buildinfo in binaries)
# - npm-global-packages.txt : global npm packages (name@version)
# - pip-user-packages.txt   : python user-site packages (pip freeze)
# - pipx-packages.txt       : pipx-installed apps
# - cargo-packages.txt      : cargo-installed binaries (crate@version)
# - gem-packages.txt        : ruby gems (names)
#
# Notes:
# - These files will be rewritten as plain lists (no section headers).

SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
ALL_OUT="$SCRIPT_DIR/all-packages.txt"
AUR_OUT="$SCRIPT_DIR/aur-packages.txt"
FLATPAK_OUT="$SCRIPT_DIR/flatpak-packages.txt"
GO_OUT="$SCRIPT_DIR/go-packages.txt"
NPM_OUT="$SCRIPT_DIR/npm-global-packages.txt"
PIP_USER_OUT="$SCRIPT_DIR/pip-user-packages.txt"
PIPX_OUT="$SCRIPT_DIR/pipx-packages.txt"
CARGO_OUT="$SCRIPT_DIR/cargo-packages.txt"
GEM_OUT="$SCRIPT_DIR/gem-packages.txt"

need() {
  command -v "$1" >/dev/null 2>&1 || {
    echo "Missing required command: $1" >&2
    exit 1
  }
}

need pacman

echo "Updating: $ALL_OUT"
pacman -Qqe | sort -u > "$ALL_OUT"

echo "Updating: $AUR_OUT"
pacman -Qqm | sort -u > "$AUR_OUT"

if command -v flatpak >/dev/null 2>&1; then
  echo "Updating: $FLATPAK_OUT"
  # flatpak list output differs by version; --columns=application is stable.
  flatpak list --app --columns=application 2>/dev/null | sed '/^[[:space:]]*$/d' | sort -u > "$FLATPAK_OUT"
else
  echo "flatpak not found; skipping $FLATPAK_OUT"
fi

if command -v npm >/dev/null 2>&1 && command -v node >/dev/null 2>&1; then
  echo "Updating: $NPM_OUT"
  {
    echo "# Generated by packages/update-packages.sh"
    echo "# Format: <name>@<version>"
    echo
    npm -g ls --depth=0 --json 2>/dev/null \
      | node -e 'const fs=require("fs"); const data=JSON.parse(fs.readFileSync(0,"utf8")||"{}"); const deps=data.dependencies||{}; for (const [name, meta] of Object.entries(deps)) { const v=(meta&&meta.version)||""; process.stdout.write(name + (v?("@"+v):"") + "\n"); }'
  } | sed '/^[[:space:]]*$/d' | sort -u > "$NPM_OUT"
else
  echo "npm/node not found; skipping $NPM_OUT"
fi

if command -v python3 >/dev/null 2>&1; then
  echo "Updating: $PIP_USER_OUT"
  {
    echo "# Generated by packages/update-packages.sh"
    echo "# Source: python user-site"
    echo "# Format: pip freeze (name==version)"
    echo
    python3 -m pip list --user --format=freeze 2>/dev/null || true
  } | sed '/^[[:space:]]*$/d' | sort -u > "$PIP_USER_OUT"
else
  echo "python3 not found; skipping $PIP_USER_OUT"
fi

if command -v pipx >/dev/null 2>&1; then
  echo "Updating: $PIPX_OUT"
  {
    echo "# Generated by packages/update-packages.sh"
    echo "# Format: <app>"
    echo
    pipx list --short 2>/dev/null || true
  } | sed '/^[[:space:]]*$/d' | sort -u > "$PIPX_OUT"
else
  echo "pipx not found; skipping $PIPX_OUT"
fi

if command -v cargo >/dev/null 2>&1; then
  echo "Updating: $CARGO_OUT"
  {
    echo "# Generated by packages/update-packages.sh"
    echo "# Format: <crate>@<version>"
    echo
    cargo install --list 2>/dev/null \
      | awk 'match($0, /^([A-Za-z0-9_-]+)[[:space:]]+v([^:]+):$/, m) { print m[1] "@" m[2] }' \
      || true
  } | sed '/^[[:space:]]*$/d' | sort -u > "$CARGO_OUT"
else
  echo "cargo not found; skipping $CARGO_OUT"
fi

if command -v gem >/dev/null 2>&1; then
  echo "Updating: $GEM_OUT"
  {
    echo "# Generated by packages/update-packages.sh"
    echo "# Format: <gem-name>"
    echo
    gem list --no-versions 2>/dev/null || true
  } | sed '/^[[:space:]]*$/d' | sort -u > "$GEM_OUT"
else
  echo "gem not found; skipping $GEM_OUT"
fi

if command -v go >/dev/null 2>&1; then
  echo "Updating: $GO_OUT"

  # Determine where Go installs binaries.
  # - If GOBIN is set (or go env GOBIN), that's used.
  # - Otherwise, use first entry in GOPATH + /bin.
  GOBIN="$(go env GOBIN 2>/dev/null || true)"
  if [[ -z "${GOBIN}" ]]; then
    GOPATH="$(go env GOPATH 2>/dev/null || true)"
    GOPATH_FIRST="${GOPATH%%:*}"
    GOBIN="${GOPATH_FIRST}/bin"
  fi

  {
    echo "# Generated by packages/update-packages.sh"
    echo "# Source: go buildinfo from binaries in: ${GOBIN}"
    echo "# Format: <module-path>@<version> (best-effort, only for binaries with module version info)"
    echo

    if [[ -d "${GOBIN}" ]]; then
      while IFS= read -r -d '' bin; do
        # Skip non-regular files.
        [[ -f "$bin" ]] || continue

        # Extract main package path + module version.
        # go version -m output example:
        #   path    github.com/.../cmd/tool
        #   mod     github.com/... v1.2.3 h1:...
        info="$(go version -m "$bin" 2>/dev/null || true)"
        [[ -n "${info}" ]] || continue

        path="$(awk '$1=="path"{print $2; exit}' <<<"$info")"
        mod_version="$(awk '$1=="mod"{print $3; exit}' <<<"$info")"

        # Only list tools that have a usable version for go install.
        [[ -n "${path}" ]] || continue
        [[ -n "${mod_version}" ]] || continue
        [[ "${mod_version}" != "(devel)" ]] || continue

        echo "${path}@${mod_version}"
      done < <(find "$GOBIN" -maxdepth 1 -type f -perm -u+x -print0 2>/dev/null || true)
    fi
  } | sed '/^[[:space:]]*$/N;/^\n$/D' | sort -u > "$GO_OUT"
else
  echo "go not found; skipping $GO_OUT"
fi

echo "Done."


